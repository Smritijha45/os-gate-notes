# ğŸ“˜ Memory Management â€“ Complete GATE Notes (Operating Systems)

---

# ğŸ“Œ 1. What is Memory Management?

**Memory Management** is the functionality of the OS that:

âœ” Allocates memory to processes  
âœ” Keeps track of memory usage  
âœ” Protects process memory  
âœ” Ensures efficient utilization  

---

# ğŸ“Œ 2. Address Binding

Mapping logical address â†’ physical address.

---

## ğŸ”¹ Types of Address Binding

1ï¸âƒ£ Compile-Time  
2ï¸âƒ£ Load-Time  
3ï¸âƒ£ Execution-Time  

---

### ğŸ”¹ Compile-Time Binding
- Physical address known at compile time
- Absolute code generated

---

### ğŸ”¹ Load-Time Binding
- Address decided when program loaded
- Relocatable code

---

### ğŸ”¹ Execution-Time Binding
- Address mapped during execution
- Requires hardware support (MMU)

---

# ğŸ“Œ 3. Logical vs Physical Address

| Feature | Logical Address | Physical Address |
|----------|----------------|------------------|
| Generated By | CPU | Memory Unit |
| Also Called | Virtual Address | Real Address |
| Visible To | User | Hardware |

---

## ğŸ”¹ MMU (Memory Management Unit)

Hardware that translates logical address â†’ physical address.

---

# ğŸ“Œ 4. Swapping

Process moved from main memory â†’ disk  
Later brought back.

Used when:
- Memory is full
- Increase degree of multiprogramming

---

# ğŸ“Œ 5. Contiguous Memory Allocation

Process occupies contiguous block of memory.

---

## ğŸ”¹ Types:

1ï¸âƒ£ Single Partition  
2ï¸âƒ£ Fixed Partition  
3ï¸âƒ£ Variable Partition  

---

# ğŸ“Œ 6. Fragmentation

---

## ğŸ”¹ Internal Fragmentation

Unused memory inside allocated block.

Occurs in:
- Fixed partition
- Paging

---

## ğŸ”¹ External Fragmentation

Free memory exists but not contiguous.

Occurs in:
- Variable partition
- Segmentation

---

# ğŸ“Œ 7. Solutions to Fragmentation

âœ” Compaction  
âœ” Paging  
âœ” Segmentation  

---

# ğŸ“Œ 8. Paging (Very Important for GATE)

Memory divided into:

- Pages (Logical)
- Frames (Physical)

Page size = Frame size

---

## ğŸ”¹ Address Format in Paging

```
Logical Address = Page Number + Offset
```

---

## ğŸ”¹ Page Table

Stores mapping:
```
Page Number â†’ Frame Number
```

---

## ğŸ”¹ Page Table Entry Contains

- Frame number
- Valid bit
- Protection bit
- Dirty bit
- Reference bit

---

# ğŸ“Œ 9. Paging Example

If:
- Page size = 1KB
- Logical address = 2050

Page number = 2050 / 1024  
Offset = 2050 % 1024

---

# ğŸ“Œ 10. Multi-Level Paging

Used when page table too large.

Instead of single page table:
- Divide into multiple levels

Reduces memory usage.

---

# ğŸ“Œ 11. TLB (Translation Lookaside Buffer)

Small, fast memory cache.

Stores recent page table entries.

---

## ğŸ”¹ TLB Hit

Page found in TLB â†’ Faster access

## ğŸ”¹ TLB Miss

Search page table â†’ Slower

---

## ğŸ”¹ Effective Memory Access Time (EAT)

```
EAT = h Ã— (TLB time + Memory time) +
      (1 - h) Ã— (TLB time + 2 Ã— Memory time)
```

Where:
h = TLB hit ratio

---

# ğŸ“Œ 12. Segmentation

Memory divided into logical segments:

- Code
- Data
- Stack

---

## ğŸ”¹ Logical Address in Segmentation

```
< Segment Number, Offset >
```

---

## ğŸ”¹ Segment Table Contains

- Base address
- Limit

---

## ğŸ”¹ Comparison: Paging vs Segmentation

| Feature | Paging | Segmentation |
|----------|--------|--------------|
| Division | Fixed size | Variable size |
| Fragmentation | Internal | External |
| User View | No | Yes |

---

# ğŸ“Œ 13. Virtual Memory

Allows execution of processes not fully in memory.

Uses:
- Demand Paging

---

# ğŸ“Œ 14. Demand Paging

Pages loaded only when required.

---

## ğŸ”¹ Page Fault

Occurs when page not in memory.

Steps:
1. Trap to OS
2. Load page from disk
3. Update page table
4. Restart instruction

---

# ğŸ“Œ 15. Page Replacement Algorithms (Very Important)

When memory is full:

---

## ğŸ”¹ 1. FIFO

Replace oldest page.

âŒ Beladyâ€™s anomaly possible.

---

## ğŸ”¹ 2. LRU (Least Recently Used)

Replace least recently used page.

âœ” Better than FIFO  
âŒ Hard to implement perfectly  

---

## ğŸ”¹ 3. Optimal

Replace page not used for longest future time.

âœ” Minimum page faults  
âŒ Not implementable (theoretical)

---

## ğŸ”¹ 4. LFU (Least Frequently Used)

Replace page with lowest reference count.

---

# ğŸ“Œ 16. Beladyâ€™s Anomaly

Increasing frames increases page faults.

Occurs in:
âœ” FIFO  
âŒ Not in LRU or Optimal  

---

# ğŸ“Œ 17. Thrashing

When:
- Too many page faults
- CPU utilization drops

System spends more time swapping than executing.

---

# ğŸ“Œ 18. Working Set Model

Keeps track of pages used recently.

Helps prevent thrashing.

---

# ğŸ“Œ 19. Important GATE Points

âœ” Logical vs Physical address  
âœ” TLB EAT formula  
âœ” Paging calculations  
âœ” Page replacement numericals  
âœ” Beladyâ€™s anomaly  
âœ” Segmentation vs Paging  
âœ” Internal vs External fragmentation  

---

# ğŸ“Œ 20. Quick Revision Summary

- Memory management maps logical â†’ physical address
- Paging removes external fragmentation
- Segmentation supports logical division
- TLB improves access time
- Demand paging loads pages on request
- LRU better than FIFO
- Thrashing reduces performance

---
